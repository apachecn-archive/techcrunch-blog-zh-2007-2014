<html>
<head>
<title>Learning The Hard Way That DNS Is Insecure: Attack Details Now Public | TechCrunch</title>
<link href="../Styles/Style.css" type="text/css" rel="stylesheet"/>
</head>
<body>
<h1 class="translated">学到DNS不安全的惨痛教训:攻击细节现已公开| TechCrunch</h1>
<blockquote>原文：<a href="https://web.archive.org/web/https://techcrunch.com/2008/07/22/learning-the-hard-way-that-dns-is-insecure-attack-details-now-public/">https://web.archive.org/web/https://techcrunch.com/2008/07/22/learning-the-hard-way-that-dns-is-insecure-attack-details-now-public/</a></blockquote><div><div class="article-content">
				<p id="speakable-summary" class="translated">有时候，完全披露安全漏洞对每个人都有好处，有时候则不然。一个不太成功的例子是安全研究员丹·卡明斯基最近“发现”的DNS安全漏洞。几周前，在他与黑帽会议的组织者召开了一次新闻发布会后，供应商们匆忙解决了这个bug的细节(他故意对细节含糊其辞)并发布了补丁。攻击的全部细节本应由卡明斯基于8月6日在<a href="https://web.archive.org/web/20230224043609/http://www.blackhat.com/html/bh-usa-08/bh-us-08-main.html">黑帽大会上披露，但在此期间，攻击的全部细节已经泄露——使网络上的大量DNS服务器暴露于中毒攻击。</a></p>
<p class="translated">该攻击依赖于父查找请求中使用的不良随机序列生成和不良端口选择。DNS服务器在请求链中向上查询响应，根据接收响应的端口(通常很容易猜到)和序列ID(通常不是很随机)来授权响应。攻击者只需在强制查找后将数千个“响应”数据包发送回请求服务器，如果猜中了正确的序列号，则服务器将在TTL指定的时间内缓存响应。</p>
<p class="translated">攻击非常简单，并且利用了域名系统运行方式中的一个核心弱点。正如许多其他研究人员指出的那样，这种攻击也不是新的。DNS系统的缺陷早已为人所知，猜测伪造响应序列号的脚本已经存在多年。DNS中毒攻击很难检测，并可能导致对易受攻击的服务器进行简单的大规模网络钓鱼攻击。</p>
<p class="translated">如果你运行的是DNS服务器，最好的办法是联系你的供应商，或者将你的父请求指向<a href="https://web.archive.org/web/20230224043609/http://www.opendns.com/"> OpenDNS </a>，它们不容易受到这种方法的攻击。攻击的完整描述如下:</p>
<p class="translated"><span id="more-337563"/></p>
<blockquote><p class="translated">Reliable<br/> DNS Forgery in 2008: Kaminskyâ€™s Discovery<br/> from Matasano Chargen by ecopeland<br/> 0.<br/> The cat is out of the bag. Yes, Halvar Flake figured out the flaw Dan<br/> Kaminsky will announce at Black Hat.<br/> 1.<br/> Pretend for the moment that you know only the basic function of DNS â€”<br/> that it translates WWW.VICTIM.COM into 1.2.3.4. The code that does this<br/> is called a resolver. Each time the resolver contacts the DNS to<br/> translate names to addresses, it creates a packet called a query. The<br/> exchange of packets is called a transaction. Since the number of<br/> packets flying about on the internet requires scientific notation to<br/> express, you can imagine there has to be some way of not mixing them<br/> up.<br/> Bob goes to to a deli, to get a sandwich. Bob walks up to the counter,<br/> takes a pointy ticket from a round red dispenser. The ticket has a<br/> number on it. This will be Bobâ€™s unique identifier for his sandwich<br/> acquisition transaction. Note that the number will probably be used<br/> twice â€” once when he is called to the counter to place his order and<br/> again when heâ€™s called back to get his sandwich. If youâ€™re wondering,<br/> Bob likes ham on rye with no onions.<br/> If youâ€™ve got this, you have the concept of transaction IDs, which are<br/> numbers assigned to keep different transactions in order. Conveniently,<br/> the first sixteen bits of a DNS packet is just such a unique<br/> identifier. Itâ€™s called a query id (QID). And with the efficiency of<br/> the deli, the QID is used for multiple transactions.<br/> 2.<br/> Until very recently, there were two basic classes of DNS<br/> vulnerabilities. One of them involves mucking about with the QID in DNS<br/> packets and the other requires you to know the Deep Magic.<br/> First, QIDs.<br/> Bobâ€™s a resolver and Alice is a content DNS server. Bob asks Alice for<br/> the address of WWW.VICTIM.COM. The answer is 1.2.3.4. Mallory would<br/> like the answer to be 6.6.6.0.<br/> It is a (now not) secret shame of mine that for a great deal of my<br/> career, creating and sending packets was, to me, Deep Magic. Then it<br/> became part of my job, and I learned that it is surprisingly trivial.<br/> So put aside the idea that forging IP packets is the hard part of<br/> poisoning DNS. If Iâ€™m Mallory and Iâ€™m attacking Bob, how can he<br/> distinguish my packets from Aliceâ€™s? Because I canâ€™t see the QID in his<br/> request, and the QID in my response wonâ€™t match. The QID is the only<br/> thing protecting the DNS from Mallory (me).<br/> QID attacks began in the olden days, when BIND simply incremented the<br/> QID with every query response. If you can remember 1995, hereâ€™s a<br/> workable DNS attack. Think fast: 9372 + 1. Did you get 9372, or even<br/> miss and get 9373? You win, Alice loses. Mallory sends a constant<br/> stream of DNS responses for WWW.VICTIM.COM. All are quietly discarded<br/> â€”- until Mallory gets Bob to query for WWW.VICTIM.COM. If Malloryâ€™s<br/> response gets to your computer before the legitimate response arrives<br/> from your ISPâ€™s name server, you will be redirected where Mallory tells<br/> you youâ€™re going.<br/> Obvious fix: you want the QID be randomly generated. Now Alice and<br/> Mallory are in a race. Alice sees Bobâ€™s request and knows the QID.<br/> Mallory has to guess it. The first one to land a packet with the<br/> correct QID wins. Randomized QIDs give Alice a big advantage in this<br/> race.<br/> But thereâ€™s a bunch more problems here: * If you convince Bob to ask<br/> Alice the same question 1000 times all at once, and Bob uses a<br/> different QID for each packet, you made the race 1000 times easier for<br/> Mallory to win. * If Bob uses a crappy random number generator, Mallory<br/> can get Bob to ask for names she controls, like WWW.EVIL.COM, and watch<br/> how the QIDs bounce around; eventually, sheâ€™ll break the RNG and be<br/> able to predict its outputs. * 16 bits just isnâ€™t big enough to provide<br/> real security at the traffic rates we deal with in 2008.<br/> Your computerâ€™s resolver is probably a stub. Which means it wonâ€™t<br/> really save the response. You donâ€™t want it to. The stub asks a real<br/> DNS server, probably run by your ISP. That server doesnâ€™t know<br/> everything. It canâ€™t, and shouldnâ€™t, because the whole idea of DNS is<br/> to compensate for the organic and shifting<br/> nature of internet naming and addressing. Frequently, that server has<br/> to go ask another, and so on. The cool kids call this â€œrecursionâ€.<br/> Responses carry another value, too, called a time to live (TTL). This<br/> number tells your name server how long to cache the answer. Why?<br/> Because they deal with zillions of queries. Whoever wins the race<br/> between Alice and Mallory, their answer gets cached. All subsequent<br/> responses will be dropped. All future requests for that same data,<br/> within the TTL, come from that answer. This is good for whoever wins<br/> the race. If Alice wins, it means Mallory canâ€™t poison the cache for<br/> that name. If Mallory wins, the next 10,000 or so people that ask that<br/> cache where WWW.VICTIM.COM is go to 6.6.6.0.<br/> 3.<br/> Then thereâ€™s that other set of DNS vulnerabilities. These require you<br/> to pay attention in class. They havenâ€™t really been talked about since<br/> 1997. And theyâ€™re hard to find, because you have to understand how DNS<br/> works. In other words, you have to be completely crazy. Lazlo Hollyfeld<br/> crazy. Iâ€™m speaking of course of RRset poisoning.<br/> DNS has a complicated architecture. Not only that, but not all name<br/> servers run the same code. So not all of them implement DNS in exactly<br/> the same way. And not only that, but not all name servers are<br/> configured properly.<br/> I just described a QID attack that poisons the name serverâ€™s cache.<br/> This attack requires speed, agility and luck, because if the â€œrealâ€<br/> answer happens to arrive before your spoofed one, youâ€™re locked out.<br/> Fortunately for those of you that have a time machine, some versions of<br/> DNS provide you with another way to poison the name serverâ€™s cache<br/> anyway. To explain it, I will have to explain more about the format of<br/> a DNS packet.<br/> DNS packets are variable in length and consist of a header, some flags<br/> and resource records (RRs). RRs are where the goods ride around. There<br/> are up to three sets of RRs in a DNS packet, along with the original<br/> query. These are: * Answer RRâ€™s, which contain the answer to whatever<br/> question you asked (such as the A record that says WWW.VICTIM.COM is<br/> 1.2.3.4) * Authority RRâ€™s, which tell resolvers which name servers to<br/> refer to to get the complete answer for a question * Additional RRâ€™s,<br/> sometimes called â€œglueâ€, which contain any additional information<br/> needed to make the response effective.<br/> A word about the Additional RRâ€™s. Think about an NS record, like the<br/> one that COMâ€™s name server uses to tell us that, to find out where<br/> WWW.VICTIM.COM is, you have to ask NS1.VICTIM.COM. Thatâ€™s good to know,<br/> but itâ€™s not going to help you unless you know where to find<br/> NS1.VICTIM.COM. Names are not addresses. This is a chicken and egg<br/> problem. The answer is, you provide both the NS record pointing<br/> VICTIM.COM to NS1.VICTIM.COM, and the A record pointing NS1.VICTIM.COM<br/> to 1.2.3.1.<br/> Now, letâ€™s party like itâ€™s 1995.<br/> Download the source code for a DNS implementation and hack it up such<br/> that every time it sends out a response, it also sends out a little bit<br/> of evil â€” an extra Additional RR with bad information. Then letâ€™s set<br/> up an evil server with it, and register it as EVIL.COM. Now get a bunch<br/> of web pages up with IMG tags pointing to names hosted at that server.<br/> Bob innocently loads up a page with the malicious tags which coerces<br/> his browser resolve that name. Bob asks Alice to resolve that name.<br/> Here comes recursion: eventually the query arrives at our evil server.<br/> Which sends back a response with an unexpected (evil) Additional RR.<br/> If Aliceâ€™s cache honors the unexpected record, itâ€™s 1995 â€”- buy CSCO!<br/> â€”- and you just poisoned their cache. Worse, it will replace the â€œrealâ€<br/> data already in the cache with the fake data. You asked where<br/> WWW.EVIL.COM was (or rather, the image tags did). But Alice also â€œfound<br/> outâ€ where WWW.VICTIM.COM was: 6.6.6.0. Every resolver that points to<br/> that name server will now gladly forward you to the website of the<br/> beast.<br/> 4.<br/> Itâ€™s not 1995. Itâ€™s 2008. There are fixes for the attacks I have<br/> described.<br/> Fix 1:<br/> The QID race is fixed with random IDs, and by using a strong random<br/> number generator and being careful with the state you keep for queries.<br/> 16 bit query IDs are still too short, which fills us with dread. There<br/> are hacks to get around this. For instance, DJBDNS randomizes the<br/> source port on requests as well, and thus wonâ€™t honor responses unless<br/> they come from someone who guesses the ~16 bit source port. This brings<br/> us close to 32 bits, which is much harder to guess.<br/> Fix 2:<br/> The RR set poisoning attack is fixed by bailiwick checking, which is a<br/> quirky way of saying that resolvers simply remember that if theyâ€™re<br/> asking where WWW.VICTIM.COM is, theyâ€™re not interested in caching a new<br/> address for WWW.GOOGLE.COM in the same transaction.<br/> Remember how these fixes work. Theyâ€™re very important.<br/> And so we arrive at the present day.<br/> 5.<br/> Letâ€™s try again to convince Bob that WWW.VICTIM.COM is 6.6.6.0.<br/> This time though, instead of getting Bob to look up WWW.VICTIM.COM and<br/> then beating Alice in the race, or getting Bob to look up WWW.EVIL.COM<br/> and slipping strychnine into his ham sandwich, weâ€™re going to be clever<br/> (sneaky).<br/> Get Bob to look up AAAAA.VICTIM.COM. Race Alice. Aliceâ€™s answer is<br/> NXDOMAIN, because thereâ€™s no such name as AAAAA.VICTIM.COM. Mallory has<br/> an answer. Weâ€™ll come back to it. Alice has an advantage in the race,<br/> and so she likely beats Mallory. NXDOMAIN for AAAAA.VICTIM.COM.<br/> Aliceâ€™s advantage is not insurmountable. Mallory repeats with<br/> AAAAB.VICTIM.COM. Then AAAAC.VICTIM.COM. And so on. Sometime, perhaps<br/> around CXOPQ.VICTIM.COM, Mallory wins! Bob believes CXOPQ.VICTIM.COM is<br/> 6.6.6.0!<br/> Poisoning CXOPQ.VICTIM.COM is not super valuable to Mallory. But<br/> Mallory has another trick up her sleeve. Because her response didnâ€™t<br/> just say CXOPQ.VICTIM.COM was 6.6.6.0. It also contained Additional RRs<br/> pointing WWW.VICTIM.COM to 6.6.6.0. Those records are in-bailiwick: Bob<br/> is in fact interested in VICTIM.COM for this query. Mallory has<br/> combined attack #1 with attack #2, defeating fix #1 and fix #2. Mallory<br/> can conduct this attack in less than 10 seconds on a fast Internet link.</p></blockquote>
			</div>

			</div>    
</body>
</html>